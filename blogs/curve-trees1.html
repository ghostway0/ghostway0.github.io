<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="the internet">
  <link rel="stylesheet" href="../assets//style.css">
  <title>Curve-Trees Blog</title>
</head>
<body>
  <header>
    <h1>Curve-Trees Blog</h1>
    <p><em></em></p>
  </header>

  <nav>
    <ul>
      <li><a href="/">Home</a></li>
    </ul>
  </nav>
  
  <main>
    <div id="txtdiv">
      <p>Curve Trees <span class="citation"
      data-cites="cryptoeprint:2022/756"><a
      href="#ref-cryptoeprint:2022/756"
      role="doc-biblioref">[1]</a></span> are a cryptographic data
      structure used to accumulate values and prove if values are
      members of the accumulated set. They are to be used in Monero’s
      FCMP (Full Chain Membership Proofs)<a href="#fn1"
      class="footnote-ref" id="fnref1"
      role="doc-noteref"><sup>1</sup></a> – the future replacement of
      ring signatures – and for a good reason:</p>
      <table>
      <thead>
      <tr>
      <th></th>
      <th>d-CLSAG <span class="citation"
      data-cites="cryptoeprint:2019/654"><a
      href="#ref-cryptoeprint:2019/654"
      role="doc-biblioref">[2]</a></span> (d=1)</th>
      <th>Curve Trees</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td>set size</td>
      <td>90</td>
      <td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>40</mn></msup><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></td>
      </tr>
      <tr>
      <td>proof size</td>
      <td>2.9KiB</td>
      <td>2.9KiB</td>
      </tr>
      </tbody>
      </table>
      <p>Furthermore, they eliminate the need for Monero’s 10 block lock
      rule, as they don’t leak decoys<a href="#fn2" class="footnote-ref"
      id="fnref2" role="doc-noteref"><sup>2</sup></a>. Currently, Monero
      uses the ring signature’s key image to prevent double spends of
      the same ‘enote’<a href="#fn3" class="footnote-ref" id="fnref3"
      role="doc-noteref"><sup>3</sup></a>; Seraphis separated these into
      a proof of membership and a proof of authorization, letting ‘pure’
      membership proof schemes – such as Curve Trees – to be used.</p>
      <h2 id="why-should-i-care">Why should I care?</h2>
      <ul>
      <li>You don’t want to read the paper, but want to read about curve
      trees,</li>
      <li>You think this is cool,</li>
      <li>???? &lt;– That’s the best part!</li>
      <li>Profit.</li>
      </ul>
      <p>Because you clicked on whatever link brought you to a page
      about Curve Trees; obviously, you’re interested. Anyway, who
      doesn’t want to impress their friends with crypto knowledge at the
      next party? “Curve Trees are a multi-level marketi- set membership
      scheme, that lets you be your own boss! You just need to invest
      <em>a bit</em>. Commit here, here here and here.” Instant party
      hit.</p>
      <h2 id="assumed-knowledge">Assumed knowledge</h2>
      <p>You must have basic math knowledge about fields and groups<span
      class="citation" data-cites="cseedu:brubaker/152groups"><a
      href="#ref-cseedu:brubaker/152groups"
      role="doc-biblioref">[3]</a></span>. Elliptic curves can be
      treated as an algebraic construct that is defined over a field
      called the base field. You do need to assume, even as merely a
      black box, that points on elliptic curves form a cyclic (and thus
      also an abelian, better known as a commutative) group, with the
      identity being the “point at infinity”
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒪</mi><annotation encoding="application/x-tex">\mathcal{O}</annotation></semantics></math>.
      For an introduction, look at <a
      href="https://www.math.brown.edu/johsilve/Presentations/WyomingEllipticCurve.pdf">these
      slides</a>. This post is not self contained, but I keep quite a
      comprehensive <a href="#references">bibliography</a> at the end.
      Note the use of
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a, b \rangle</annotation></semantics></math>
      to represent the inner product<a href="#fn4" class="footnote-ref"
      id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
      <figure>
      <img src="https://i.ibb.co/9qcDws4/untitled-8.png"
      alt="Elliptic Curves! (xkcd 2048)" />
      <figcaption aria-hidden="true">Elliptic Curves! (xkcd
      2048)</figcaption>
      </figure>
      <p>The Curve Trees paper assumes the hardness of the Discrete Log
      Problem (DLP). It basically means that it is hard to find
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
      from the knowledge of
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
      and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
      with the relation
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>G</mi><mo>=</mo><munder><munder><mrow><mi>G</mi><mo>+</mo><mi>…</mi><mo>+</mo><mi>G</mi></mrow><mo accent="true">⏟</mo></munder><mtext mathvariant="normal">n times</mtext></munder><mo>=</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">[n]G = \underbrace{G + \ldots + G}_{\text{n times}} = P</annotation></semantics></math>.</p>
      <p>Many zero-knowledge proofs use what’s called C&amp;P (Commit
      and Prove) schemes: they commit to a value–something that lets
      them ‘represent’ the value without revealing it–and then prove
      with that commitment some knowledge.</p>
      <p>Commitments are functions on vectors which:</p>
      <ol type="1">
      <li><p>bind to the committed value: it is computationally hard to
      commit to a value, and then find another opening (value) that
      ‘encodes’ to the same commitment; and</p></li>
      <li><p>also are perfectly or computationally hiding.</p></li>
      </ol>
      <p>Pedersen commitments are commonly used in ZK proofs and
      structures: they are homomorphic<a href="#fn5"
      class="footnote-ref" id="fnref5"
      role="doc-noteref"><sup>5</sup></a>, simple and lightweight –
      making them an easy choice. They are defined as
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>∑</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><msub><mi>G</mi><mi>i</mi></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>s</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>v</mi><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>s</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>∈</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">Com(v, s) = \sum [v_i]G_i + [s]H = \langle v, G \rangle + [s]H \in E[\mathbb{F}_q]</annotation></semantics></math>,
      where
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
      is the blinding factor and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
      is the opening, or the vector we are committing to.
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub><mo>,</mo><mi>H</mi><mo>∈</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">G_i,H \in E[\mathbb{F}_q]</annotation></semantics></math>,
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[\mathbb{F}_q]</annotation></semantics></math>
      being an elliptic curve on the field
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>q</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_q</annotation></semantics></math>.
      You’d notice I’m using
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>q</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_q</annotation></semantics></math>
      and not the usual
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>p</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_p</annotation></semantics></math>
      – that’s on purpose. :)</p>
      <p>Pedersen commitments are great for yet another reason: they are
      re-randomizable. So if you have a tree, 1. you can re-randomize
      its entries so that it cannot be linked to the other tree, and 2.
      it’s really easy (computationally) to do so.
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>v</mi><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> </mtext><mspace width="0.333em"></mspace></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Rerand(Com(v, s), r) = Com(v, s) + [r]H = \langle v, G \rangle \text{ } + [s + r]H = Com(v, s + r)</annotation></semantics></math></p>
      <p>In curve trees, Pedersen commitments are used as a compressor
      function at every level of the tree. Think Merkle Trees, but using
      Pedersen commitments as a hash and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo><mtext mathvariant="normal">degree</mtext></mrow><annotation encoding="application/x-tex">2 \cdot \text{degree}</annotation></semantics></math>
      field elements –
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math><a
      href="#fn6" class="footnote-ref" id="fnref6"
      role="doc-noteref"><sup>6</sup></a> of
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">degree</mtext><annotation encoding="application/x-tex">\text{degree}</annotation></semantics></math>
      points as
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>.
      You would notice that, because the elliptic curve group is cyclic,
      scalars – the ones we use for multiplication operations on the
      elliptic curve – are essentially modulo the order of the group,
      or, in its scalar field<a href="#fn7" class="footnote-ref"
      id="fnref7" role="doc-noteref"><sup>7</sup></a>. Say
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>p</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_p</annotation></semantics></math>
      is
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[\mathbb{F}_q]</annotation></semantics></math>’s
      scalar field.
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>∈</mo><msub><mi>𝔽</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">x,y \in \mathbb{F}_q</annotation></semantics></math>,
      but they also need to be in
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>p</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_p</annotation></semantics></math>.
      Naturally<a href="#fn8" class="footnote-ref" id="fnref8"
      role="doc-noteref"><sup>8</sup></a>, we ask why can’t
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p = q</annotation></semantics></math>,
      but that is not possible, or at least not possible to do securely
      <span class="citation"
      data-cites="cryptoeprint:2014/595 cryptostackexchange:106774"><a
      href="#ref-cryptoeprint:2014/595" role="doc-biblioref">[5, Sec.
      3.1]</a>, <a href="#ref-cryptostackexchange:106774"
      role="doc-biblioref">[6]</a></span>.</p>
      <p>This ‘type mismatch’ has been seen before in zk proofs: earlier
      methods, such as and some ETH zero knowledge contracts, emulate(d)
      field arithmetic on one field with operations on another for the
      exact same reason; committing produces results in the base field,
      and proving needs to work on the scalar field <span
      class="citation"
      data-cites="blogicme:canweavoidcycles blogpersonlabs:efficientecdsa"><a
      href="#ref-blogicme:canweavoidcycles"
      role="doc-biblioref">[7]</a>, <a
      href="#ref-blogpersonlabs:efficientecdsa"
      role="doc-biblioref">[8]</a></span> <a href="#fn9"
      class="footnote-ref" id="fnref9"
      role="doc-noteref"><sup>9</sup></a>. That’s called “wrong field
      arithmetic” or “non-native arithmetic”, and is too slow to be
      practical: circuits using it can be 100 to 200 times larger<span
      class="citation" data-cites="slides:deepdiveonhalo2"><a
      href="#ref-slides:deepdiveonhalo2" role="doc-biblioref">[10, p.
      38]</a></span>. They found that we could, however, define that two
      elliptic curves have complementing cardinalities and orders, as
      in, one’s scalar field being the base field of the other. meaning
      every odd and even layers will be points of
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow></msub><annotation encoding="application/x-tex">E_{odd}</annotation></semantics></math>
      and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow></msub><annotation encoding="application/x-tex">E_{even}</annotation></semantics></math>
      respectively, using the pedersen commitment as an adaptor. that
      would work, but do such curves exist?</p>
      <figure>
      <img
      src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10623-022-01135-y/MediaObjects/10623_2022_1135_Fig1_HTML.png"
      alt="Elliptic curve Cycles [11]" />
      <figcaption aria-hidden="true">Elliptic curve Cycles <span
      class="citation" data-cites="springer:asurveyproofsys"><a
      href="#ref-springer:asurveyproofsys"
      role="doc-biblioref">[11]</a></span></figcaption>
      </figure>
      <p>Surprisingly, yes!</p>
      <p>(A bit) More formally, Curve Trees are the algebraic structure
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mo>ℓ</mo><mo>,</mo><msub><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow></msub><mo>,</mo><msub><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\ell, E_{even}, E_{odd})</annotation></semantics></math>,
      where
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>ℓ</mo><annotation encoding="application/x-tex">\ell</annotation></semantics></math>
      is the branching factor of the tree, with the
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>ℓ</mo><annotation encoding="application/x-tex">\ell</annotation></semantics></math>
      children at each layer compressed by their parent with the
      alternating compression functions
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><msub><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow></msub></msub><mo>:</mo><mspace width="1.0em"></mspace><msubsup><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><mo>ℓ</mo></msubsup><mo>↦</mo><msub><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{E_{even}}: \quad E_{odd}^{\ell} \mapsto E_{even}</annotation></semantics></math>
      and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><msub><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow></msub></msub><mo>:</mo><mspace width="1.0em"></mspace><msubsup><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><mo>ℓ</mo></msubsup><mo>↦</mo><msub><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{E_{odd}}: \quad E_{even}^{\ell} \mapsto E_{odd}</annotation></semantics></math>
      being Pedersen commitments as explained earlier. The tree is
      defined recursively, where leaves make up the set of values we can
      commit to. Those are compressed by the aforementioned compression
      function, until the root is reached.</p>
      <figure>
      <img src="https://i.ibb.co/FH9GkCT/2024-06-28-21-42.png"
      alt="Curve Trees paper [1] fig. 3; The orange path is the path to the leaf." />
      <figcaption aria-hidden="true">Curve Trees paper <span
      class="citation" data-cites="cryptoeprint:2022/756"><a
      href="#ref-cryptoeprint:2022/756"
      role="doc-biblioref">[1]</a></span> fig. 3; The orange path is the
      path to the leaf.</figcaption>
      </figure>
      <p>Let’s return to why we even wanted this construction: we wanted
      a tree.</p>
      <p>Just kidding, we wanted to prove that a value we selected is in
      some set. So how can we do that here? We can publish the path to
      the value, but that wouldn’t be zero-knowledge. We need something
      to prove we did the procedure correctly! Choosing Pedersen
      commitments was a fortunate choice in this regard, as many
      efficient proof systems exist for them, such as Bulletproofs<span
      class="citation" data-cites="cryptoeprint:2017/1066"><a
      href="#ref-cryptoeprint:2017/1066"
      role="doc-biblioref">[12]</a></span> (which I’ll cover in the next
      post), many SNARKs/STARKs, PLONK, etc. Those systems allow you to
      prove that we built the tree correctly, by constraining the
      commitment to be generated by its children, and the path element
      be one of them, but re-ranzomized. In the paper, Bulletproofs are
      used to generate a proof for these re-randomized commitments, and
      because we use different curves for odd and even layers, we
      generate two proofs: one for the odd layers and the other for the
      even ones.</p>
      <figure>
      <img src="https://imgs.xkcd.com/comics/tree.png"
      alt="We love trees! (xkcd 835)" />
      <figcaption aria-hidden="true">We love trees! (xkcd
      835)</figcaption>
      </figure>
      <p>Bulletproofs are incredibly interesting and are a centric
      component for this scheme/structure. The next blog is going to be
      concerned with how they work and the generalization the authors
      provided to enable this structure. Thanks for reading!</p>
      <h1 id="references">References</h1>
      <div id="refs" class="references csl-bib-body"
      data-entry-spacing="0" role="list">
      <div id="ref-cryptoeprint:2022/756" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[1] </div><div
      class="csl-right-inline">M. Campanelli, M. Hall-Andersen, and S.
      H. Kamp, <span>“Curve trees: Practical and transparent
      zero-knowledge accumulators.”</span> Cryptology ePrint Archive,
      Paper 2022/756, 2022. Available: <a
      href="https://eprint.iacr.org/2022/756">https://eprint.iacr.org/2022/756</a></div>
      </div>
      <div id="ref-cryptoeprint:2019/654" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[2] </div><div
      class="csl-right-inline">B. Goodell, S. Noether, and A. Blue,
      <span>“Concise linkable ring signatures and forgery against
      adversarial keys.”</span> Cryptology ePrint Archive, Paper
      2019/654, 2019. Available: <a
      href="https://eprint.iacr.org/2019/654">https://eprint.iacr.org/2019/654</a></div>
      </div>
      <div id="ref-cseedu:brubaker/152groups" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[3] </div><div
      class="csl-right-inline">B. Brubaker, <span>“The very basics of
      groups, rings, and fields.”</span> 2006. Available: <a
      href="https://www-users.cse.umn.edu/~brubaker/docs/152/152groups.pdf">https://www-users.cse.umn.edu/~brubaker/docs/152/152groups.pdf</a></div>
      </div>
      <div id="ref-electriccoin:pastahalo2" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[4] </div><div
      class="csl-right-inline">S. B. Daira Hopwood and J. Grigg,
      <span>“The pasta curves for halo 2 and beyond.”</span> Electric
      Coin Blog, 2020. Available: <a
      href="https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/">https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/</a></div>
      </div>
      <div id="ref-cryptoeprint:2014/595" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[5] </div><div
      class="csl-right-inline">E. Ben-Sasson, A. Chiesa, E. Tromer, and
      M. Virza, <span>“Scalable zero knowledge via cycles of elliptic
      curves.”</span> Cryptology ePrint Archive, Paper 2014/595, 2014.
      Available: <a
      href="https://eprint.iacr.org/2014/595">https://eprint.iacr.org/2014/595</a></div>
      </div>
      <div id="ref-cryptostackexchange:106774" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[6] </div><div
      class="csl-right-inline">D. S, Answered on Crypto Stack Exchange,
      2023. Available: <a
      href="https://crypto.stackexchange.com/a/106775">https://crypto.stackexchange.com/a/106775</a></div>
      </div>
      <div id="ref-blogicme:canweavoidcycles" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[7] </div><div
      class="csl-right-inline">W. Benno, <span>“Can we avoid cycles of
      curves.”</span> Blog, 2023. Available: <a
      href="https://blog.icme.io/can-we-avoid-cycles-of-curves/">https://blog.icme.io/can-we-avoid-cycles-of-curves/</a></div>
      </div>
      <div id="ref-blogpersonlabs:efficientecdsa" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[8] </div><div
      class="csl-right-inline">Personae, <span>“Efficient ECDSA &amp;
      the case for client-side proving.”</span> Blog, 2022. Available:
      <a
      href="https://personaelabs.org/posts/efficient-ecdsa-1/">https://personaelabs.org/posts/efficient-ecdsa-1/</a></div>
      </div>
      <div id="ref-blogicme:costofrecursion" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[9] </div><div
      class="csl-right-inline">W. Benno, <span>“The cost of composition:
      An exploration in the state of the art for foreign field
      arithmetic in zero knowledge proofs.”</span> ICME blog, 2024.
      Available: <a
      href="https://blog.icme.io/the-cost-of-recursion-explorations-in-the-state-of-the-art-of-foreign-arithmetic/">https://blog.icme.io/the-cost-of-recursion-explorations-in-the-state-of-the-art-of-foreign-arithmetic/</a></div>
      </div>
      <div id="ref-slides:deepdiveonhalo2" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[10] </div><div
      class="csl-right-inline">D. Hopwood and Y. T. Lai, <span>“Deep
      dive on halo 2.”</span> Github Repo, 2020. Available: <a
      href="https://raw.githubusercontent.com/daira/halographs/master/deepdive.pdf">https://raw.githubusercontent.com/daira/halographs/master/deepdive.pdf</a></div>
      </div>
      <div id="ref-springer:asurveyproofsys" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[11] </div><div
      class="csl-right-inline">Y. E. H. Diego F. Aranha and A.
      Guillevic, <span>“A survey of elliptic curves for proof
      systems.”</span> 2022-2023. Available: <a
      href="https://link.springer.com/article/10.1007/s10623-022-01135-y">https://link.springer.com/article/10.1007/s10623-022-01135-y</a></div>
      </div>
      <div id="ref-cryptoeprint:2017/1066" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[12] </div><div
      class="csl-right-inline">D. B. Benedikt Bünz Jonathan Bootle and
      G. Maxwell, <span>“Bulletproofs: Short proofs for confidential
      transactions and more.”</span> Cryptology ePrint Archive, Paper
      2017/1066, 2017. Available: <a
      href="https://eprint.iacr.org/2017/1066">https://eprint.iacr.org/2017/1066</a></div>
      </div>
      <div id="ref-bernstein2012highspeed" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[13] </div><div
      class="csl-right-inline">D. J. Bernstein, N. Duif, T. Lange, P.
      Schwabe, and B.-Y. Yang, <span>“High-speed high-security
      signatures,”</span> <em>Journal of Cryptographic Engineering</em>,
      vol. 2, Aug. 2012, doi: <a
      href="https://doi.org/10.1007/s13389-012-0027-1">10.1007/s13389-012-0027-1</a>.</div>
      </div>
      <div id="ref-githubgist:curve-tower-cycle" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[14] </div><div
      class="csl-right-inline">tevador, <span>“Elliptic curve
      tower-cycle for Curve25519.”</span> A Github Gist, 2024.
      Available: <a
      href="https://gist.github.com/tevador/4524c2092178df08996487d4e272b096">https://gist.github.com/tevador/4524c2092178df08996487d4e272b096</a></div>
      </div>
      </div>
      <h1 id="appendix-a---curve-tower-cycles">Appendix A - Curve-Tower
      Cycles</h1>
      <p>Many protocols and implementations use Curve25519, or more
      specifically, its Twisted Edwards form <span class="citation"
      data-cites="bernstein2012highspeed"><a
      href="#ref-bernstein2012highspeed"
      role="doc-biblioref">[13]</a></span>. But secure curve cycles with
      it are impossible because the order of its (sub)group (generated
      by its generator point
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>)
      is not prime, meaning
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>G</mi><mo>=</mo><mi>𝒪</mi></mrow><annotation encoding="application/x-tex">[n]G = \mathcal{O}</annotation></semantics></math>
      where
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
      isn’t prime. Notice that if we could find a 2-cycle with curve
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>#</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>𝕡</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">\#E[\mathbb{F_p}] = q</annotation></semantics></math>
      and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>#</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>𝕢</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\#E[\mathbb{F_q}] = p</annotation></semantics></math>
      and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msup><mn>2</mn><mn>255</mn></msup><mo>−</mo><mn>19</mn></mrow><annotation encoding="application/x-tex">p = 2^{255} - 19</annotation></semantics></math><a
      href="#fn10" class="footnote-ref" id="fnref10"
      role="doc-noteref"><sup>10</sup></a>, points on Curve25519 could
      be mapped to points on
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>𝕢</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[\mathbb{F_q}]</annotation></semantics></math>,
      and ‘enter’ the cycle. This is well defined because they have the
      same number of points, meaning they can be mapped between each
      other.</p>
      <pre><code>   -- Ep --
 /          \
|            ^
v            |
 \          /
   -- Eq --
      ^
      |
  Curve25519</code></pre>
      <p>tevador called this arrangement a “tower-cycle”. For more
      details about the generation of such curves, tevador posted a gist
      on GitHub <span class="citation"
      data-cites="githubgist:curve-tower-cycle"><a
      href="#ref-githubgist:curve-tower-cycle"
      role="doc-biblioref">[14]</a></span>.</p>
      <figure>
      <img src="https://imgs.xkcd.com/comics/depth_and_breadth.png"
      alt="Finding curves is fun! But… Bread is probably tastier. (xkcd 2407)" />
      <figcaption aria-hidden="true">Finding curves is fun<a
      href="#fn11" class="footnote-ref" id="fnref11"
      role="doc-noteref"><sup>11</sup></a>! But… Bread is probably
      tastier. (xkcd 2407)</figcaption>
      </figure>
      <section id="footnotes"
      class="footnotes footnotes-end-of-document" role="doc-endnotes">
      <hr />
      <ol>
      <li id="fn1"><p>This was just a sidenote – you don’t have to
      understand nor know about FCMPs.<a href="#fnref1"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn2"><p>Ring signatures use decoys to obstruct peopole
      from knowing who the sender is. However, due to how PoW works,
      recents committed blocks can be reordered or removed from the
      chain, thus comprimising privacy. Basically, an attacker can spam
      the network with double spends and force a reorg, and if other
      users use their outputs as decoys, the attacker can deanonymize
      them. Koe talked about this more <a
      href="https://github.com/monero-project/research-lab/issues/95">here</a>.<a
      href="#fnref2" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn3"><p>An enote is an output of a transaction, and can be
      spent once. Change can be saved by having two outputs: one for the
      actual recipient, and one for the change.<a href="#fnref3"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn4"><p>The inner product here is the dot product: take
      two vectors
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo>∈</mo><msup><mi>𝔾</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">v_1, v_2 \in \mathbb{G}^n</annotation></semantics></math>
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>v</mi><msub><mn>1</mn><mi>i</mi></msub></msub><mo>⋅</mo><msub><mi>v</mi><msub><mn>2</mn><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">\langle v_1, v_2 \rangle = \sum_{i=1}^n v_{1_i} \cdot v_{2_i}</annotation></semantics></math>.
      Inner product with an elliptic curve group would take
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><msup><mi>𝔾</mi><mi>n</mi></msup><mo>,</mo><mover><mi>G</mi><mo accent="true">→</mo></mover><mo>∈</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">v \in \mathbb{G}^n, \vec{G} \in \mathbb{E}[\mathbb{F}_q]</annotation></semantics></math>
      and compute
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><msub><mover><mi>G</mi><mo accent="true">→</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n [v_i]\vec{G}_i</annotation></semantics></math>.<a
      href="#fnref4" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn5"><p>Homomorphic means that there exists a
      homomorphism, a function from one group to another s.t.
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊗</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>⊕</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H(a) \otimes H(b) = H(a \oplus b)</annotation></semantics></math>.
      You can see why Pedersen commitments are homomorphic here:
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mo>+</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">Com(v_1, s_1) + Com(v_2, s_2) = \langle v_1, G \rangle + \langle v_2, G \rangle</annotation></semantics></math>
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> </mtext><mspace width="0.333em"></mspace></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">\text{ } + [s_1]H + [s_2]H = \langle v_1 + v_2, G \rangle + [s_1 + s_2]H</annotation></semantics></math>
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> </mtext><mspace width="0.333em"></mspace></mrow><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{ } = Com(v_1 + v_2, s_1 + s_2)</annotation></semantics></math>.
      Note that
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>+</mi><annotation encoding="application/x-tex">+</annotation></semantics></math>
      means different things here: at first it’s point addition on the
      elliptic curve and then it is vector addition.<a href="#fnref5"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn6"><p>The paper assumes you can represent the point at
      infinity, the identity of the elliptic curve group, as (x, y)
      coordinates (in
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><msub><mi>𝔽</mi><mi>q</mi></msub><mn>2</mn></msup><annotation encoding="application/x-tex">{\mathbb{F}_q}^2</annotation></semantics></math>),
      which is true for the pasta curves<span class="citation"
      data-cites="electriccoin:pastahalo2"><a
      href="#ref-electriccoin:pastahalo2"
      role="doc-biblioref">[4]</a></span>.<a href="#fnref6"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn7"><p>This field’s cardinality is the same as the order
      of the elliptic curve’s subgroup generated by the point. In
      simpler words, its size is the same as the number of points on the
      elliptic curve that we can generate using that point
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>.
      It is a field if and only if
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>#</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>𝔽</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\#E[\mathbb{F}]</annotation></semantics></math>
      is prime (and thus the subgroup is actually the whole group),
      which is necessary for a curve cycle (defined later). That is not
      the case for curves with cofactor
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h &gt; 1</annotation></semantics></math>.
      See <a href="#appendix-a-curve-tower-cycles">Appendix A</a>. For
      more information about subgroups you can read <a
      href="https://crypto.stackexchange.com/questions/95752/how-to-decide-if-a-point-on-a-elliptic-curve-belongs-to-a-group-generated-by-a-g">here</a>.<a
      href="#fnref7" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn8"><p>Using transformations on the field doesn’t work;
      modulo will introduce bias to certain points, for example.<a
      href="#fnref8" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn9"><p>Also, “Proof composition involves verifying proofs
      that themselves verify other proofs, requiring "nesting" of
      operations in different fields” <span class="citation"
      data-cites="blogicme:costofrecursion"><a
      href="#ref-blogicme:costofrecursion"
      role="doc-biblioref">[9]</a></span>, and thus inherently needs to
      operate on wrong fields.<a href="#fnref9" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn10"><p>Base field characteristic of Curve25519.<a
      href="#fnref10" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn11"><p>Those aren’t the right search
      algorithms/constraints, but you get the point.<a href="#fnref11"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      </ol>
      </section>
    </div>
  </main>
</body>
</html>
