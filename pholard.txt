|=----------------------------------------------------------------------=|
|=------------------=[ From Pollard To Chenyilei ]=---------------------=|
|=----------------------------------------------------------------------=|

|=----------------------------------------------------------------------=|
1 Introduction
2 Classical
    2.1 Preliminaries
        2.1.1 A Brief On Groups
        2.1.2 DLP And Factorization
    2.2 The Pollard Rho and Pohlig–Hellman Algorithms
3 Quantum Cryptanalysis
    3.1 Preliminaries
    3.2 Shor's Algorithm
    3.3 Grover's Algorithm
    3.4 Kyber
        3.4.1 Lattices, Coding Theory And Polynomials
        3.4.2 Learning With Errors
        3.4.3
    3.5 Algorithms For Solving LWE
        3.5.1 What Happened?
        3.5.2 The Algorithm
            3.5.2.1 Fourier Transform
            3.5.2.2 Quantum Fourier
            3.5.2.3 Hand Waving Until I Fly Away
        3.5.3 Memory Modeling In The Quantum World
4 Hybrid Schemes
5 Closing Words
|=----------------------------------------------------------------------=|

--[ 1 Introduction

With TLS v1.3 underway to all our browsers, understanding how some of the
underlying cryptography works--and when it doesn't--is, well, not essential,
but at least it's fun.

--[ 2 Classical

--[ 2.1 Preliminaries

Elliptic curves

--[ 2.1.1 A Brief On Groups

--[ 2.1.2 DLP And Factorization

--[ 2.2 The Pollard Rho and Pohlig–Hellman Algorithms

The Pohlig–Hellman algorithm and the Pollard's Rho method are two
complimenting methods for finding discrete logarithms, and they are the basis
of the attacks against elliptic curves today, with some concurrency
improvements. Both of them are incredibly clever and hide some interesting
connections to some elemenetary algorithms and ideas. Pohlig-Hellman splits
the problem into multiple smaller problems which we can solve independently
and afterwards merge the results.

Simply put, cyclic groups are groups where one element 'generates' all the
other elements by applying the group operation to itself many times. The
order of the group is the number of elements that are generated by that
generator element until it 'resets' to itself. I'll use multiplication
to denote that repeated addition. Cyclic groups follow Lagrange's theorem,
which--in this case--means we can treat multiples as modulo order - 1,
and are abelian (commutative).

Composite order elliptic curve groups are used everywhere nowadays after
the popularization of Curve25519. (Naturally,) Their order is in the form of
order=h*p, and you may have heard that cofactor h has to be 'small'. That's
because Pohlig-Hellman can split the DLP within that composite-order group--
the order of which being the product of prime powers--into separate, smaller
problems.

* continue talking about the actual thing here

The classic cycle-finding algorithm uses two pointers, where you advance one
pointer once, and the other twice. We are told that these pointers are going
to meet some time, and when they do, we backtrack a bit to find the cycle.
Apparently, that algorithm is generalizable to any (cyclic) group! Pollard's
Rho method is named after the rho (p) shape the cycling pointers 'take'.

Remember the DLP is defined as finding y such that [n]A = P where x and b are
in some (cyclic) group G. Let's try to generalize that method to arbitrary*
cyclic groups.

Instead of adding one step and two steps, it works by applying
f(x) to one group element and f(f(x)) to another, where f if it's cyclic, and
random enough. That f can be a constructed like this: Disjoint the elliptic
curve group (optionally randomly) into 3 [2] sets (denoted with S1, S2 and
S3), and define a different operation for each set. This is done in a way
that we can track their linear combinations so at the end it is possible to
combine the operations easily.

More specifically, f(Ai) = Ai + P if Ai is in S1, 2Ai if Ai in S2, and Ai + Q
if Ai is in S3. Because Ai = [n1]P + [n2]Q, if we find a nontrivial solution
to Ai = Aj we can find the discrete logarithm with some algebraic magickery.
This will find a collision on average within O(sqrt(n)) operations[3].

--[ Quantum

introduce quantum somehow
why are amplitudes complex
QFT
Shor
Grover
LWE
hand waving til I start flying

--[ Closing Words

--[ References

Aaron, 2015: http://koclab.cs.ucsb.edu/teaching/ecc/project/2015Projects/
Blumenfeld-Paper.pdf

[1]: Read along; the next section would hopefully make it clear why.

[2]: An arbitrary choice in my understanding. 2 probably was too little,
     and more functions may not be faster in practice. See (Aaron, 2015)
     for details.

[3]: This is due to a birthday paradox bound. In short, the number of
     possible pairs (read: collisions) grows quadratically, and when our f is
     random 'enough', those two pointer-group-elements would find each other
     quite fast!

https://nigelsmart.github.io/LWE.html
https://datatracker.ietf.org/doc/html/rfc2785
https://eprint.iacr.org/2024/555
https://www.reddit.com/r/crypto/comments/vr45g3/relationship_between_lattices_and_polynomials/
https://www1.cmc.edu/pages/faculty/lenny/papers/cyclic.pdf
https://eprint.iacr.org/2014/1026.pdf
https://eprint.iacr.org/2024/1041.pdf
https://docs.google.com/document/d/1nOSMP103FyJN5ynGk20ajtN2U1z9wopjZMk_xadQonc/edit?tab=t.0
https://math.stackexchange.com/questions/824123/what-is-an-embedding-degree-of-elliptic-curve
https://www.youtube.com/watch?v=B0p0jbCGvWk
https://www-ee.stanford.edu/~hellman/publications/28.pdf
https://web.eecs.umich.edu/~cpeikert/pubs/rlwe-challenges.pdf

https://link.springer.com/chapter/10.1007/978-3-642-34961-4_27
https://eprint.iacr.org/2017/314
https://www.scottaaronson.com/papers/island.pdf
